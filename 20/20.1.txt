#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
main(){
    /* автоматичне визначення графічного драйвера */
    int gdriver = DETECT, gmode, errorcode;  // gdriver і gmode використовуються для автоматичного визначення графічного режиму, errorcode для перевірки помилок
    int i, size;  // i використовується як лічильник в циклі, size для зберігання розміру буфера
    void *buf;  // указівник для зберігання зображення
    /* ініціалізація графічного режиму */
    initgraph(&gdriver, &gmode, "");  // Ініціалізація графічного режиму з автоматичним визначенням драйвера і режиму
    /* перевірка результату ініціалізації */
    errorcode = graphresult();  // Отримання коду результату ініціалізації
    /* якщо сталася помилка */
    if (errorcode != grOk){
        printf("Графічна помилка: %s\n", grapherrormsg(errorcode));  // Виведення повідомлення про помилку
        printf("Натисніть будь-яку клавішу для завершення:");  // Запит на натискання клавіші для завершення
        getch();  // Очікування натискання клавіші
        exit(1);  // Завершення програми з кодом 1 (помилка)
    }
    setcolor(BLACK);  // Встановлення кольору для подальших графічних операцій
    setfillstyle(1, RED);  // Встановлення стилю заливки (1 - суцільна заливка, RED - червоний колір)
    fillellipse(21, 240, 20, 20);  // Малювання заповненого еліпса з центром у точці (21, 240) і радіусами 20
    /* розрахунок розміру буфера, необхідного для збереження зображення */
    size = imagesize(1, 220, 41, 260);  // Обчислення розміру пам'яті, необхідної для збереження області зображення
    buf = malloc(size);  // Виділення пам'яті для збереження зображення
    if (buf == NULL) {
        printf("Помилка виділення пам'яті\n");  // Виведення повідомлення про помилку, якщо пам'ять не була виділена
        closegraph();  // Закриття графічного режиму
        exit(1);  // Завершення програми з кодом 1 (помилка)
    }
    getimage(1, 220, 41, 260, buf);  // Збереження області екрана розміром 41x260 з координатами лівого верхнього кута (1, 220) у буфер
    setfillstyle(1, BLACK);  // Встановлення стилю заливки (1 - суцільна заливка, BLACK - чорний колір)
    for(i = 1; i <= 620; i++)  // Цикл для переміщення еліпса по екрану
    {
        bar(i - 1, 220, i + 39, 260);  // Очищення попереднього положення еліпса. Задається прямокутник, який перекриває попереднє положення еліпса
        putimage(i, 220, buf, COPY_PUT);  // Відображення зображення з буфера у новій позиції. (i, 220) - нова координата лівого верхнього кута зображення
        delay(10);  // Затримка на 10 мс для створення ефекту анімації
    }
    free(buf);  // Звільнення виділеної пам'яті для буфера
    closegraph();  // Закриття графічного режиму і повернення екрану у текстовий режим
 return 0;  }